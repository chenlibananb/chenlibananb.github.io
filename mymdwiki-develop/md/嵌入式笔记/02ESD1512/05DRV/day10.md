```
回顾：
1.linux内核mmap机制
  本质：将设备的物理地址映射到用户虚拟地址上
  对比ioremap:将设备的物理地址映射到内核虚拟地址上
2.linux内核platform机制
  2.1.linux内核分离思想
      本质：驱动具有很好的可移植性,驱动代码便于维护
  2.2.分离思想实现依据platform机制
      platform机制的实现过程：边说边画
  2.3.驱动关心两个数据结构
     struct platform_device
     	.name
     	.id
     	.resource
     		.start
     		.end
     		.flags
     			IORESOURCE_MEM
     			IORESOURCE_IRQ
     	.num_resources
     	.dev
     		.release
    platform_device_register
    platform_device_unregister
    
    struct platform_driver
    	.driver 
    		.name
    	.probe 匹配成功
    	.remove 卸载软或者硬
   
    platform_driver_register
    platform_driver_unregister
   
   总结：probe函数是否被调用至关重要！
   通过probe或者remove形参pdev指针获取硬件信息的方法：
   struct resource *platform_get_resource(
   			struct platform_device *pdev,
   			unsigned long flags,
   			int index)
   函数功能：通过probe或者remove形参pdev指针获取硬件信息
   参数：
   pdev:pdev指向匹配成功的硬件信息
   flags：硬件信息的类型
          IORESOURCE_MEM/IORESOURCE_IRQ
   index:同类资源的偏移量
   
   返回值：返回对应的硬件信息的首地址

作业：将之前的按键驱动采用platform机制实现

***********************************************************
3.I2C总线
  面试题：谈谈对I2C总线的理解
  3.1.功能
  明确：硬件上,CPU一天到晚在跟外设进行通信,需要一定的通信方式
        例如：LED,通过GPIO;BT,通过UART等
        I2C总线类似GPIO或者UART,也是CPU和外设通信的一种相当
        重要的方式！
  明确：它是实实在在的硬件总线
  
  3.2.定义
  两线式串行总线(飞利浦)
  “两线式”：CPU跟外设通过I2C总线数据的通信只需2根信号线
  	    分别为数据线SDA和时钟控制信号线SCL
  SDA：数据信号线,用来传输数据,此数据线CPU和外设都可以进行
       "控制"(CPU向设备发数据,SDA由CPU控制;CPU从外设读取数据,SDA
       	      由外设控制)
       总结：“控制”：谁配输出谁控制,谁配输入谁释放
                     不能同时配输出,但是可以同时配输入
  SCL：时钟控制信号线,用来同步双方的数据传输,由于CPU的处理
  	速度远远快于外设,如何保证双方的数据时同步的呢,如何
  	保证外设能够正常处理数据呢？需要SCL进行同步数据，
  	SCL只能由CPU发起(控制)
  	假如：
  	CPU在SCL为高电平时,将数据放到SDA上,那么设备就应该
  	在同周期的SCL为低电平时,从数据线SDA上获取数据
  	以：CPU向设备写1和0为例,画出时序操作图	      
  "上拉电阻"：SDA和SCL都需要连接一个上拉电阻,默认的电平状态
  	      为高电平
  “串行”：一个时钟周期传输1个bit位,传输1字节数据,需要8个
          时钟周期
  “总线”：在这两根信号线上可以挂接多个外设
  画出I2C总线的连接示意图    
  
  3.3.看图提问题：
  1.CPU如何访问(定位)到I2C总线上的某个外设？ 
  2.如果CPU定位了某个外设,那么CPU如何通过2根信号线和外设
    进行通信呢？
  3.SDA和SCL如何搭配使用呢？(如果不配合,一根线更好)
  答：答案在I2C总线传输协议中 
  3.4.I2C总线传输协议相关内容
  master=CPU
  slave=外设
  1.搞清楚相关概念
  START信号：又称起始信号,此信号只能由CPU发起,表示CPU开始
  	     访问I2C总线,SCL为高电平SDA由高电平向低电平跳变产生START信号
  	     类似：同学们上课了
  STOP信号：又称结束信号,此信号同样只能由CPU发起,表示CPU
  	    结束对I2C总线的访问,SCL为高电平,SDA由低电平向
  	    高电平跳变产生STOP信号,类似：同学们下课了
  	    切记：会画出START和STOP时序图
  
  读写位R/W:用来表示CPU到底是写设备还是读设备,如果CPU写设备,R/W=0；如果CPU读设备,R/W=11
  
  设备地址：设备地址表示外设在总线上的唯一性,同一个I2C总线
  	    上外设,有不同的设备地址,类似身份证号,将来如何
  	    CPU要访问I2C总线上某个外设,CPU只需向总线上
  	    发送对应外设的设备地址即可,类似：喊某个人的身份证号
  	    外设的设备地址由外设的芯片厂家(芯片手册)和原理图
  	    共同来决定！
  	    切记：一定要搞清楚外设的设备地址,否则CPU将来
  	    无法访问外设！
  	    
  	    以温度传感器LM77为例,打开LM77芯片手册lm77.pdf:
  	    P8获取到LM77的设备地址：10010A1A0
  	    加入：A1A0硬件工程师都接地A1A0=00
  	    最终LM77的设备地址=1001000(高位补0)=01001000=0x48
  	    读设备地址=0x48<<1 | 1
  	    写设备地址=0x48<<1 | 0
  	    
  	    以AT24C02存储器为例,打开AT24C02芯片手册at24c02.pdf:
  	    P11,得到AT24C02的设备地址信息1010A2A1A0R/W
  	    切记：设备地址不包括R/W位=>并且A2A1A0都接地
  	    AT24C02的设备地址=1010000(高位补0)=01010000=0x50
  	    
  	    如果设备地址加上读写位,会得到两个另外的地址：
  	    读设备地址=设备地址<<1 | R/W=设备地址<<1|1
  	    写设备地址=设备地址<<1 | R/W=设备地址<<1|0
  	    =>AT24C02的：
  	    设备地址=0x50
  	    读设备地址=0x50<<1|1=0xa1
  	    写设备地址=0x50<<1|0=0xa0
  	    
  	    以ADP8860背光灯控制芯片为例,打开芯片手册adp8860.pdf:
  	    P26,得到ADP8860的读写设备地址分别是：
  	    读设备地址=0x55
  	    写设备地址=0x54
  	    设备地址=0x2A
  	    
  ACK应答信号：又称响应,表示CPU和外设数据通信的状态,低电平
               有效	    
  
  切记：IIC=I2C数据传输一次1字节,1周期1bit
  
  总结：1.CPU如何访问(定位)到I2C总线上的某个外设？
  答：CPU通过向总线上发送这个外设的设备地址进行定位
  
  2.如果CPU定位了某个外设,那么CPU如何通过2根信号线和外设
    进行通信呢？
  答：切记具体通信的过程一定要参看外设的芯片手册！
      找到芯片手册中相关的I2C时序操作图！
      
  以LM77温度传感器为例,掌握I2C数据传输过程：P12
  参看CPU读取LM77内部寄存器2byte数据操作过程为例：
  1.CPU向总线发送START信号
  2.CPU向总线发送LM77的设备地址包括读写位=1
  3.如果LM77存在于总线上,LM77在第九个时钟周期给CPU发送一个
    ACK应答信号(类似：老师,我在)
  4.设备向CPU发送高字节数据
  5.CPU读取完毕,CPU同样在第九个时钟周期给设备发送一个ACK
    信号(类似：读完了)
  6.设备继续向CPU发送低字节的数据
  7.CPU读取完毕,CPU无需向设备发送ACK信号,切记切记虽然
    ACK没有发送,但是第九个时钟周期一定要有！
  8.CPU最后向总线发送STOP信号,结束数据的读取
  边说边画图(圈圈框框)
  
  以AT24C02存储器为例,操作需求如下：
  1.AT24C02存储器类似Nand
  2.AT24C02存储容量256字节
    内部地址编址：0x00~0xff
  需求：
  1.CPU向AT24C02片内某个地址0x10存储空间中写入数据0x55
  2.CPU从AT24C02片内某个地址0x10读取数据
  
  切记：一定要参看AT24C02的操作时序图,找到读和写的时序图
        P11
  整理：CPU向AT24C02片内某个地址0x10存储空间中写入数据0x55
  1.CPU向总线发送START信号
  2.CPU向总线发送写设备地址(设备地址+读写位=0)
  3.设备如果存在于总线上,设备在第九个时钟周期给CPU发一个ACK信号
  4.CPU向总线发送要访问的片内地址0x10
  5.设备在第九个时钟周期给CPU发送ACK信号
  6.CPU向总线发送要写入的数据0x55
  7.设备在第九个时钟周期给CPU发送ACK信号
  8.CPU向总线发送STOP结束数据的写
  画图
  
  整理：CPU从AT24C02片内某个地址0x10读取数据,P12(随机读时序)
  具体参见时序图
  
  总结：
  1.明确：I2C外设的任何操作都是在芯片手册的时序图中
  2.打开I2C外设的芯片手册,找两样东西：
    1.一般I2C外设内部都是由各种寄存器,找到这些访问的寄存器
      信息,然后确定这些片内寄存器的地址,尤其要注意,I2C外设的
      片内寄存器的地址不能以地址指针的形式访问,因为这些地址
      不是CPU直接寻址的地址,这些寄存器地址的访问要严格按照
      相关的时序图进行操作即可
    2.然后根据读或者写找到对应的读写操作时序图
  
  案例：掌握RTC:实时时钟硬件单元,用来保存实际时间
        这里选择RTC芯片：mcp79412芯片
  1.打开芯片手册
  2.找到寄存器的位置
    确定寄存器的地址和说明
  3.找到对应的寄存器读或者写的操作时序图
  
  3.问：SCL和SDA如何搭配使用呢？
    答：时钟SCL为低电平时,数据线上的数据可以进行修改
        时钟SCL为高电平时,数据线上的数据保存锁定稳定状态
        例如：CPU向设备写1
        CPU就应该在SCL为低电平将1放到数据线上SDA上(拉高)
        那么设备就应该在同周期SCL为高电平从数据线上获取数据
        
        例如：CPU从设备读取数据
        CPU应该拉低SCL,为了让设备能够将数据放到数据线上
        CPU然后将SCL拉高,让数据线上的数据锁定稳定
        最后CPU从数据线读取数据即可
        
        这个问题的理解关键将来可以实现GPIO模拟I2C时序图
        “GPIO模拟I2C时序图”：自己编程拉高拉低SCL和SDA发起
                             相应的时序图
        边说边画图
        以HMC6352指南针传感器为例,具体的SCL和SDA的操作时序的细节：
        以CPU向HMC6352发送'S'命令,让HMC6352进入休眠模式为例：
        1.找到对应的时序图P4
        2.分析时序图
          CPU发送START
          CPU发送写设备地址
          设备给CPU发送ACK
          CPU发送‘S’=0x53命令给设备
          设备给CPU发送ACK,设备进入休眠模式
          CPU发送STOP信号
          画框框和圈圈
        3.画出CPU发送START信号和发送设备地址的具体操作时序图
          会画时序图,将来就会看示波器抓取的波形,就会分析！
        
案例：画出CPU向AT24C02片内某个地址0x10存储空间中写入数据0x55                         
      已知设备地址=0x50  
         
  
  
  
  
  
  
                  
```