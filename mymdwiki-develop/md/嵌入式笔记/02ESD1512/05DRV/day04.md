```
回顾：
1.linux内核字符设备驱动开发相关内容
  1.1.设备驱动职能
  1.2.设备驱动分类
  1.3.linux内核字符设备驱动
      1.linux理念
      2.字符设备文件
        c/b
        设备号
        	dev_t,unsigned int
        主设备号:12,应用找驱动
        次设备号:20,驱动找硬件个体
        	MKDEV
        	MAJOR
        	MINOR
        申请/释放
        	alloc_chrdev_region
		unregister_chrdev_region
        手动创建：cat /proc/devices;mknod
        自动创建：三个保证+四个函数
        设备文件作用：仅仅给open函数使用
        后序应用程序根据系统调用函数和设备驱动进行通信即可
      3.字符设备驱动相关数据结构
        struct cdev
        	dev
        	count
        	ops
        配套函数：
        cdev_init
        cdev_add
        cdev_del
        描述硬件操作接口
        struct file_operations
        	open
        	release
        		可以不用初始化
        	read：注意第二个参数buf
        	write：注意第二个参数buf
        	unlocked_ioctl：注意第三个参数arg   
        	需要利用内存拷贝函数：
        	copy_to_user
        	copy_from_user     
        	根据用户需求进行指定
        struct inode
               i_rdev
               i_cdev
        struct file
               f_op
        关系：LCD显示驱动fbmem.c参考代码
        一般应用在驱动通过次设备号区分硬件个体时使用！
        
2.linux内核混杂设备驱动开发相关内容
  2.1.概念
  从软件编程的实现过程,混杂设备驱动本质上还是字符设备驱动,
  只是混杂设备驱动的主设备号由内核已经定死,主设备号为10,
  将来各个混杂设备驱动通过次设备号进行区分！
  用混杂设备驱动编程框架相对比较简单,它是对字符设备驱动编程
  框架的进一步封装而已！
  结论：将来要实现一个字符设备驱动,可以采用混杂设备驱动编程
  框架也可以采用传统的字符设备驱动编程框架(之前所学内容)

  2.2.linux内核描述混杂设备数据结构
  struct miscdevice {
  	int minor;
  	char *name;
  	struct file_operations *fops;
  	...
  };   
  重要成员说明：
  minor:保存申请的次设备号,主设备号由内核已经定义好=10；
  	一般指定为宏：MISC_DYNAMIC_MINOR,表明让内核帮你
  	分配申请一个次设备号
  name:设备文件名,此设备文件的创建由内核自动帮你完成！
  fops：混杂设备驱动的硬件操作接口
  
  配套函数：
  注册混杂设备对象到内核
  misc_reigster(struct miscdevice *misc)
  从内核卸载混杂设备读对象
  misc_deregister (struct miscdevice *misc) 
  
  2.3.实现一个混杂设备驱动的编程步骤
  1.根据用户需求定义初始化硬件操作接口对象
    struct file_operations ...
  2.定义初始化混杂设备对象
  3.注册混杂设备对象到内核
    卸载混杂设备对象
  4.编写各个硬件操作接口
  
案例：利用混杂设备驱动编程框架实现LED驱动,接口采用ioctl
实施步骤：
1.mkdir /opt/drivers/day04/1.0 -p
2.cd /opt/drivers/day04/1.0
3.vim led_drv.c
4.vim Makefile
5.vim led_test.c
6.make
7.arm-linux-gcc -o led_test led_test.c
8.cp led_drv.ko led_test /opt/rootfs

PC机执行：
1.insmod led_drv.ko
2.ls /dev/myled -lh
3../led_test on 1
  ./led_test off 1
  ./led_test on 2
  ./led_test off 2

**********************************************************
3.linux内核中断相关内容
  面试题：谈谈对中断的理解
  3.1.为什么有中断机制
  从硬件层面上：计算机系统由CPU和外设组成,CPU一天到晚跟外设通信
  从软件层面上：计算机系统中的CPU一天到晚处理进程或者中断
  外设的处理速度远远慢于CPU,带来CPU和外设通信时的速率不匹配,
  一般来说首先可能考虑轮询机制,CPU一旦发现设备不可用,CPU不干
  别的事情,原地死等设备可用为止,如果等待时间比较长,大大降低了
  CPU的利用率,轮询一般应用在等待时间极短的情况比较好！
  如果不清楚设备什么时候准备好数据或者等待时间较长,此时必须
  使用中断机制！
  举例子：以CPU读取串口为例,阐述中断的好处
  CPU读取串口时,发现串口没有准备好数据,CPU就不再原地死等,
  可以干别的事情(处理某个进程),如果串口一旦接收到数据,串口
  通过串口控制器给CPU发送一个中断信号(类似：嗨，哥们,我准备数据了)
  CPU一旦接收到了此中断信号,停止手头的工作,转去处理串口,
  CPU处理完毕,接着执行原先被打断的工作,整个过程CPU至少做2件事情
  大大提高了CPU的利用率！
  
  3.2.中断的硬件连接和硬件的触发流程
  所有的外设产生的中断信号必须要经过中断控制器,
  经过中断控制器的一番判断以后,再决定是否给CPU发送最终的
  中断电信号！
  
  此时此刻画出中断的硬件连接示意图！
  以按键为例，谈谈中断电信号的触发流程
  按键按下->产生下降沿->中断控制器->CPU(IRQ/FIQ)->CPU接收到
                         各种判断
  中断电信号->CPU开启硬件处理->CPU开启软件处理
  
  引出中断控制器的功能：
  1.使能或者禁止某个外设中断
  2.设置将来中断采用IRQ还是FIQ发送给CPU
  3.设置中断的优先级
  4.设置中断到底给哪个CPU发送
  
  3.3.中断处理流程
  以按键为例：
    按键按下->产生下降沿->中断控制器->CPU(IRQ/FIQ)->CPU接收到
                         各种判断
  中断电信号->CPU开启硬件处理->CPU开启软件处理
  
  1.CPU硬件中断处理流程
    CPSR保存在SPSR_IRQ/SPSR_FIQ
    设置CPSR
     MODE=IRQ/FIQ
     T=0
     I=1
     F=1
    保存返回地址lr_irq/fiq=pc-4
    设置pc=0x18/0x1c(异常向量表),开启软件的中断处理流程
  2.开启软件处理之前,软件首先要创建异常项链表
    保护现场
    正式处理
    恢复现场
    中断返回(subs pc, lr, #4)
    画图：具体参见int1.bmp
    要能说能画！
    一定要谈三个词：异常向量表,保护现场,恢复现场
                   CPU资源发生了一个轮转
                   
  3.4.中断的软件编程过程
  中断要经过硬件和软件处理,只谈软件处理过程：
  明确：不管是ARM裸板程序还是linux系统,中断编程都一致！
  1.编写异常向量表的代码
  2.编写保护现场的代码
  3.编写中断正式处理,编写硬件中断对应的中断处理函数
    每当中断触发,CPU执行对应的中断处理函数
  4.编写恢复现场的代码(包括从中断返回)
  
  切记：linux内核中断编程1,2,4由内核已经实现！驱动开发者
  只需完成第3步即可！因为根据实际的用户需求完成相关内容！
  
  3.5.linux内核中断编程实施步骤：
  1.切记：硬件中断对应的中断处理函数属于内核空间代码,
          不属于用户空间！
  2.明确：linux内核中断软件处理只需将硬件中断对应的中断
          处理函数注册添加到内核即可,将来一旦硬件产生中断
          内核自动调用之前注册的中断处理函数！这也是以上所说的
          第3步！
  3.问：如何将中断处理函数注册添加到内核中？
    答：利用大名鼎鼎的两个函数：
    int request_irq(unsigned int irq,
    		    irq_handler_t handler,
    		    unsigned long flags,
    		    const char *name,
    		    void *dev)
    函数功能：
    1.切记：CPU的硬件中断资源对于内核来说同样是一种宝贵的资源
      所以驱动要想访问某个硬件中断资源,必须先向内核去申请
      硬件中断资源
    2.一旦这个硬件中断资源申请OK,然后向内核注册添加这个硬件
    中断对应的中断处理函数,一旦将来硬件中断触发,内核自动调用
    注册的中断处理函数
    
    参数说明：
    irq：内核给每一个硬件中断都分配了一个软件编号,又称中断号
         (类似身份证号),从32开始,0~31内核保留！
         中断号通过宏来表示,例如：
         硬件中断     中断号
         XEINT0	      IRQ_EINT(0)
         XETIN1	      IRQ_EINT(1)
         ...	      ...
    handler:传递要注册的中断处理函数
    	    数据类型：
    	    typedef irqreturn_t (*irq_handler_t)(int irq, 
    	    				void *dev);
	    返回值：
	    IRQ_NONE:中断不做处理,处理失败
	    IRQ_HANDLED:中断正常处理
	    IRQ_WAKE_THREAD:中断处理函数执行完毕,唤醒线程
            参数：
            irq：保存当前触发的硬件中断对应的中断号
            dev: 保存注册中断处理函数传递的参数
    flags：中断标志,注意：
    	   如果硬件中断是外部中断(能够看到中断线),flags指定一下宏即可：
    	   IRQF_TRIGGER_FALLING:下降沿为有效的触发方式
    	   IRQF_TRIGGER_RISING:上升沿为有效的触发方式
    	   IRQF_TRIGGER_HIGH:高电平为有效的触发方式
    	   IRQF_TRIGGER_LOW: 低电平为有效的触发方式
           以上宏可以做位或运算；
           例如：双边沿触发：
           IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING
           
           如果硬件中断为内部中断(中断线看不到,例如各种控制器)
           flags只需给0即可！有效的触发方式需要配置控制器对应的
           寄存器！
    
     name：中断名称,通过cat /proc/interrutps命令查看
     dev：给中断处理函数传递的参数(回忆pthread_create)
          不传参给NULL
          		    
    void free_irq(int irq, void *dev)
    函数功能：
    1.释放硬件中断资源
    2.删除中断处理函数
    
    参数：
    irq：硬件中断对应的中断号
    dev: 传递给中断处理函数的参数,切记此参数传递的信息
         一定要和注册时传递的参数信息要一致！
         不传参给NULL
         
案例：编写TPAD开发板上KEY_UP按键驱动,采用中断机制
      要求：按下或者松开,打印按键的状态
实施步骤：
0.卸载内核官方的按键驱动
  cd /opt/kernel
  make menuconfig
     Device Drivers->
     	Input device support->
     		Keyboards->
     		   <*> S3c gpio keypad ... //去掉
  保存退出
  make zImage 
  cp arch/arm/boot/zImage /tftpboot
  用新内核重启开发板
     		   	
1.mkdir /opt/drivers/day04/2.0 
2.cd /opt/drivers/day04/2.0
3.vim btn_drv.c
4.vim Makefile
5.make
6.cp btn_drv.ko /opt/rootfs

ARM执行：
1.insmod btn_drv.ko
2.cat /proc/interrupts //查看中断的注册信息
             CPU0
 16:         93    s3c-uart  s5pv210-uart
 18:        146    s3c-uart  s5pv210-uart
 32:          0  s5p_vic_eint  KEY_UP
 第一列：注册的硬件中的中断号
 第二列：硬件中断触发的次数
 第三列：硬件中断类型
 第四列：硬件中断的名称
 
3.操作按键,观察打印信息
  
4.cat /proc/interrupts //查看KEY_UP中断的触发次数?
  
案例：优化按键驱动,添加其余按键信息

3.6.linux内核对中断处理函数的要求
1.明确：CPU资源一天到晚在进程和中断处理函数之间切换
2.明确：中断处理函数仅仅属于内核,不隶属于任何进程
        所以不参与进程之间的调度,并且中断处理函数
        不会直接和用户空间进行数据的交互
3.明确：linux系统"任务"包括中断和进程
        中断又分软中断和硬件中断
4.明确：linux系统任务之间的优先级(高->低)：
        优先级：衡量任务获取CPU资源能力
        硬件中断大于软中断
        软中断大于进程
        硬件中断无优先级之分
        软中断有优先级之分
        进程有优先级之分
5.切记：linux内核要求中断处理函数的执行速度要快！
  如果中断处理函数长时间的占有CPU资源,会造成其他中断和进程
  无法及时获取到CPU资源,代表其他中断和进程无法及时投入运行
  势必会影响系统的响应能力和并发能力！
  如果有中断处理函数长时间占有CPU资源的情形,尤其要注意！
  
  如果有些场合不能满足内核的要求,此时此刻,需要利用内核的
  顶半部和底半部机制来解决这种问题！
  
3.7.顶半部和底半部机制：
    切记：只能应用在中断处理函数长时间长有CPU资源的情形！
    本质：把原先执行时间较长的中断处理函数一分为二,
    分为顶半部和底半部；
    顶半部：做原先中断处理函数中比较紧急,耗时较短的内容
            顶半部本质就是中断处理函数,也就代表着一旦硬件
            中断触发,内核首先执行顶半部的内容,执行完毕,立即
            释放CPU资源,保证其他任务在很短的时间内获取到
            CPU资源,不影响系统的响应能力和并发能力
    	    执行期间不允许被打断！
    	    
    底半部：做原先中断处理函数中耗时较长,不紧急的内容
            这部分的内容会被内核在"适当的时候"会执行
            “适当的时候”:这部分内容优先级最高
            执行期间允许被别的任务打断！
            
    总结：
    顶半部本质就是中断处理函数！
    底半部的实现方法有三种：
    tasklet
    工作队列
    软中断
    
    
    3.8.根据day04/2.0参考代码,完成其余6个按键的中断编程
        实现当按键按下或者松开,打印按键的状态和按键值
             
     
  
  
          
        

      
                  
  
  
  
  
  
  
    
  
       
        
```