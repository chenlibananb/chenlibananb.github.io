```
回顾：
1.linux内核并发竞态相关内容
  1.1.概念
  1.2.情形
  1.3.方法
  
2.linux内核等待队列机制
  2.1.区分
  消息队列：进程间通信的方法
  工作队列：延后执行的方法
  等待队列：进程在内核空间休眠的方法
  
  2.2.作用
  明确：外设速度慢于CPU
  等待：忙等和休眠等
  本质目的就是让进程在内核空间进行随时随地休眠,随时随地被唤醒
  一般和中断配合使用
  
  2.3.编程方法形式分2种
  2.4.踏踏实实牢记按键驱动编程框架
  
3.linux内核按键去抖动
  3.1.按键产生抖动原因
      按键属于一个机械结构
  3.2.明确按键操作的实际波形图
      画图
  3.3.去抖动的方案
      硬件去抖动：硬件设计的问题
      		  去抖动效果最好
      		  成本高
      软件去抖动：驱动设计的问题
                  成本低
                  效果一般
  
  3.4.linux内核按键驱动去抖动实现
      裸板程序去抖动一般采用忙延时,同样也浪费CPU资源
      内核驱动采用忙延时去抖动,太浪费CPU资源,利用定时器去抖动
      明确：抖动产生的中断信号的时间间隔经验值5-10ms
  
  案例：在昨天的按键驱动中添加按键软件去抖动
  
  面试题：请阐述如何在linux系统下编写一个硬件的设备驱动
  面试题：谈谈对按键驱动的编写理解
  答：以按键驱动为例进行阐述
  直接先说：按键必须采用中断方式,以轮询进行对比
  1.为什么中断
  2.中断硬件连接
  3.中断处理过程
  4.linux内核中断编程
  5.底半部和顶半部
  6.等待队列
  7.按键去抖动

*********************************************************
3.linux内核内存访问相关的方法
  3.1.回顾应用程序内存访问：
  int a = 100; //全局变量,数据段
  int b = 200; //局部变量,栈
  char *p = malloc(100); //堆
  总结：
  linux系统4G虚拟内存,用户进程独占前3G虚拟内存空间,
  回顾3G虚拟内存空间的划分：
  地址由低地址向高地址排：
  代码段->数据段->BSS段---->堆->MMAP内存映射区->栈
  代码    初始化  未初始化 malloc  mmap        局部变量
          全局变量 变量
          
  3.2.明确映射过程：
  不管是用户空间还是内核空间,软件访问内存都是虚拟内存,
  这些虚拟内存最终都要映射到实际的物理内存上！
  这里牵扯到在访问虚拟内存时,前提是在分配内时,操作系统
  会自动帮你将分配的虚拟内存和物理内存进行映射！
  
  内核空间占4G虚拟内存的后1G虚拟内存空间,地址范围：
  0xC0000000~0xFFFFFFFF,所有进程都会共享！
  内核给每一个进程都会分配内核栈,内核栈大小非常可怜仅有4KB
  
  用户空间3G虚拟内存和物理内存的映射属于动态映射,需要访问
  内存时,操作系统动态建立物理和虚拟的映射关系,一旦不再使用
  将映射关系解除！这种内存的访问效率不高！
  
  内核空间1G虚拟内存和物理内存的映射属于静态映射,内核在启动
  的时候就已经将物理内存和内核1G虚拟内存做好一一映射,将来
  内核软件只需直接去访问虚拟内存即可,无需动态建立映射关系，
  这种内存访问效率很高！
  假设：物理内存起始地址为0x0,"一一映射"：
  物理内存地址      内核虚拟内存地址
  0x0		    0xC0000000
  0x1               0xC0000001
  0x2		    0xC0000002
  ...		    ...
  1G                1G
  问题：如果采用一一映射,假设物理内存大于1G,内核就无法访问
  	其余的物理内存！如何访问其余的物理内存呢？
  	但还要考虑内存的访问效率！
  答：内核通过将1G内核虚拟内存划分成多个区域让内核不仅仅
      访问到所有的物理内存,还能提高内核的访问内存的效率
  
  3.3.问：如何访问linux内核1G虚拟内存呢？
  答：明确linux内核1G虚拟内存空间的划分
  X86架构,划分为以下区域：
  直接内存映射区：
  	特点：
  	大小为896M
  	直接内存映射区的虚拟内存在内核启动的时候就已经建立
  	和物理内存的一一映射关系,所以直接内存映射的内存
  	访问效率最高！
  	又称低端内存
  	
  动态内存映射区：
  	特点：
  	大小为120M
  	如果要访问其余的物理内存,可以将物理内存和动态内存
  	映射区的虚拟内存动态建立映射关系,不再使用时,记得要
  	解除映射,否则动态内存映射区的内存泄漏！
  	动态内存映射区虽然能够让内核访问所有的物理内存，
  	但是访问的效率比较低下！
  	
  永久内存映射区：
  固定内存映射区：
  	相同点：如果将来频繁访问某块物理内存,为了提高
  	内存的访问效率,可以将物理内存映射到永久或者固定
  	内存映射区,一旦映射,无需解除映射关系
  	区别：前者在映射时会导致休眠,所以不能用于中断上下文
  	      后者不会导致休眠
  
  高端内存：动态内存映射区+永久+固定内存映射区
  	      
  总结：
  内核将1G虚拟内存进行划分的本质目的就是让内核不仅仅访问到
  所有的物理内存,还能够提高内核的访问内存的效率！
  
  ARM:以S5PV210为例：通过查看内核启动信息
    区名       起始地址      结束地址     大小
    //异常向量表
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
    
    //固定内存映射区
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
    
    //DMA内存映射区
    DMA     : 0xff000000 - 0xffe00000   (  14 MB)
    
    //动态内存映射区
    vmalloc : 0xf4800000 - 0xfc000000   ( 120 MB)
    
    //直接内存映射区
    lowmem  : 0xc0000000 - 0xf4000000   ( 832 MB)
    
    modules : 0xbf000000 - 0xc0000000   (  16 MB)
      .init : 0xc0008000 - 0xc0037000   ( 188 kB)
      .text : 0xc0037000 - 0xc0832000   (8172 kB)
      .data : 0xc0832000 - 0xc0886960   ( 339 kB)
  
   注意：
   一个物理地址可以有多个映射的虚拟地址
   这个虚拟地址有可能是内核虚拟地址,还有可能是用户虚拟地址
   类似一个人可以多个名字
   
   3.4.问：驱动程序如何使用各个区域的内核虚拟内存呢？
       答：内核提供了相关的函数用来分配内存
   1.kmalloc/kfree
   函数原型：
   void *kmalloc(size_t size, gfp_t flags)  
   函数功能：
   1.从直接内存映射区分配内存
     内存的访问效率高(内核启动时就已经建立好物理和虚拟的映射关系)
   2.物理和虚拟上都连续
   
   参数：
   size:指定分配内存时的大小,单位字节
        注意：最小为32字节
              最大为4MB(老版本内核128KB)
   flags：指定分配内存时的行为,两个宏：
          GFP_KERNEL:告诉内核,请内核努力把这次内存分配的动作搞定
          	     如果内存不足,可能会导致休眠,此宏不能用于
          	     中断上下文,但是分配内存成功的概率高！
          	     
          GFP_ATOMIC:如果内存不足,不会进行休眠,而是立即返回
                     可以用在中断上下文
   返回值：返回分配的内核虚拟内存的首地址
   
   参考代码：
   char *pstring = NULL;
   pstring = (char *)kmalloc(100, GFK_KERNEL);   
   memset(pstring, 0, 100);  //清空申请的内存
   memcpy(pstring, "hello,world", 12);
   
   等价于：
   pstring = (char *)kzalloc(100, GFK_KERNEL);            
   总结：kzalloc = kmalloc+memset
   
   内存不再使用时,记得要释放：
   void kfree(void *addr)
   
  2.__get_free_pages/free_pages
  明确：linux,1页=4KB
  unsigned long __get_free_pages(gfp_t flags, int order)
  函数功能：
  1.从直接内存映射区分配内存
  2.物理和虚拟上都连续
  
  参数：
  flags:指定分配内存时的行为,两个宏：
          GFP_KERNEL:告诉内核,请内核努力把这次内存分配的动作搞定
          	     如果内存不足,可能会导致休眠,此宏不能用于
          	     中断上下文,但是分配内存成功的概率高！
          	     
          GFP_ATOMIC:如果内存不足,不会进行休眠,而是立即返回
                     可以用在中断上下文
  order:order = 0,分配1页
        order = 1,分配2页
        order = 2,分配4页
        order = 3,分配8页
        ...
        最小分配1页
        最大分配4MB
        
  返回值：返回分配内核虚拟内存的首地址,注意数据类型的转换
  
  参考代码：
  unsigned long addr;
  addr = __get_free_pages(GFP_KERNEL, 2);
  *(int *)addr = 0x55;
  
  注意：内存不再使用时,记得要释放内存：
  void free_pages(unsigned long addr, int order);
  
  3.vmalloc/vfree
  函数原型：
  	void *vmalloc(int size)
  1.从动态内存映射区分配
  2.虚拟上连续,物理上不一定连续
  
  size：指定分配内存时的大小
        理论最大值为120MB
  如果内存不足,有可能会导致休眠！
  
  参考代码：
  char *pstring;
  pstring = (char *)vmalloc(1024*1024);
  
  4.kmap/kmap_atomic分别用于永久和固定(了解)
  
  5.在内核的启动参数中设置添加vmalloc信息,例如vmalloc=250M
    就是告诉内核,在内核启动的时候,将动态内存映射区的大小由
    原先的120M调整到250M
    例如：
    setenv bootargs root=/dev/nfs nfsroot=... vmalloc=250M
    boot
    查看内核的启动信息,观察动态内存映射区和直接内存映射区
    的大小是否有变化！
  
  6.在内核的启动参数中,添加mem,例如mem=8M,告诉内核在启动的时候
  将物理内存的最后8M预留出来,将来驱动专门自己使用！
  切记切记：不管是在用户空间还是在内核空间,不允许直接访问
  设备的物理地址,如果要想访问,必须将设备的物理地址映射到
  用户空间的虚拟地址或者内核空间的虚拟地址上,将来访问用户虚拟地址
  或者访问内核虚拟地址,即可访问硬件！
  将来驱动只需利用大名鼎鼎的ioremap函数,将8M预留的物理
  内存进行映射即可！
  setenv bootargs root=/dev/nfs nfsroot=... mem=8M
  boot
  
4.linux内核大名鼎鼎的ioremap函数
  4.1.切记
  在内核空间和用户空间不允许直接访问硬件外设的物理地址
  访问之前必须将物理地址映射到内核虚拟地址上或者用户虚拟地址上
  一旦映射完毕,将来访问映射的内核虚拟地址或者用户虚拟地址就是
  在访问对应的硬件外设！
  
  CPU访问外设,最终访问外设对应的基地址即可！将来以地址
  指针形式访问即可！
  一定要先获取外设的基地址！(回忆ARM裸板开发内容)
  
  4.2.问：如何将外设的物理地址映射到内核的虚拟地址上呢？
      答：利用ioremap函数
  
  4.3.ioremap函数
  函数原型：
  void *ioremap(unsigned long phys_addr, int size)
  函数功能：
  将硬件外设的物理地址映射到内核虚拟地址上
  参数：
  phys_addr:外设的起始物理地址
  size:要映射的外设的访问"内存"空间大小
      "内存"：不单单指内存条的内存,还要例如各种寄存器(每一个寄存器的存储空间为4字节)
  
  返回值：返回映射的内核起始虚拟地址
  结果：将来访问映射的内核虚拟地址就是在访问实际的物理地址
   硬件             配置寄存器   数据寄存器
  LED1/LED2        0xE0200060    0xE0200064
  
  驱动映射：
  unsigned long *gpiocon, *gpiodata;
  gpiocon = ioremap(0xE0200060, 4);
  gpiodata = ioremap(0xE020064, 4);
  
  或者：
  gpiocon = ioremap(0xE0200060, 8); 
  gpiodata = gpiocon + 1;
  注意：前提是物理地址上必须是连续的！
  
  //配置为输出口,输出0
  *gpiocon &= ~((0xf << 12) | (0xf << 16));
  *gpiocon |= (1 << 12) | (1 << 16);
  ...
  
  不再使用时,记得要解除地址映射：
  iounmap(gpiocon);
  
  案例：不再使用GPIO库函数,通过直接访问寄存器实现开关灯
        接口为ioctl
       
周末项目任务安排：
1.制作最小根文件系统
2.移植tslib
3.移植QT
  参见project.rar/project.doc文档
  源码：project.rar
4.检验：
  能够在开发板上运行操作美女摇奖QT程序

  
  
  
  
  
    
              	
      
      
  
  
```