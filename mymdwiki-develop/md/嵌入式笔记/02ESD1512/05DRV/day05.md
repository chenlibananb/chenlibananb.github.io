```
回顾：
1.linux内核混杂设备驱动编程框架
  1.1.字符设备
  1.2.主设备10
      次设备号区分
  1.3.数据结构
      struct miscdevice
      	.minor = MISC_DYNAMIC_MINOR
      	.name = 设备文件名
      	.fops = 硬件操作接口
  1.4.配套函数
      注册：misc_register
      卸载：misc_deregister

2.linux内核中断编程
  面试题：谈谈对中断的理解
  2.1.为什么有中断
  2.2.中断硬件连接触发过程
      画图
  2.3.中断处理流程
      画图
  2.4.中断编程过程
      1.编写异常向量表的代码
      2.编写保护现场的代码
      3.根据用户需求编写中断处理函数
      4.编写返回现场的代码
      友情提示：只需关注3
  2.5.linux内核中断编程
      明确：1,2,4由内核已经写好,驱动只需完成3即可
      明确：驱动只需注册硬件中断的中断处理函数到内核即可
      大名鼎鼎函数：
      request_irq(中断号,中断处理函数名,中断标志,
      		   中断名称,给中断处理函数传递的参数);
      free_irq(中断号,给中断处理函数传递的参数);
      测试命令：cat /proc/interrupts
      
  2.6.linux内核对于中断处理函数的要求
      中断处理函数不隶属于任何进程
      不参与进程之间的调度
      不参与直接跟用户空间进行数据的交互
      优先级：硬件中断>软中断>进程
      结论：linux内核要求中断处理函数执行的速度越快越好
      	    如果中断长时间占用CPU资源,其他任务无法及时获取
      	    CPU资源,影响响应能力和并发能力
      切记切记：中断处理函数更不能做休眠操作！
      "休眠"：明确休眠一词只能存在于进程的世界里,进程休眠
      	      就是指当前进程释放它所占用的CPU资源,给别的任务
      	      使用;
      
      但是：并不是所有的中断处理函数都能够满足内核的要求,
      如果出现中断处理函数长时间占用CPU资源情形,可以考虑
      使用内核提供的中断编程框架：顶半部和底半部机制来优化
      
      画图！
  2.7.顶半部和底半部机制：
  顶半部特点：
  	1.本质上还是原先的中断处理函数
  	2.只是里面现在做原先中断处理函数比较紧急,
  	  耗时较短的内容
  	3.不可被中断,千万不能进行休眠操作
  	4.执行时间非常短,就是为了及时释放CPU资源
  
  底半部特点：
  	1.做原先中断处理函数比较耗时,不紧急的内容
  	2.可被打断(目前猜测可能基于软中断或者进程)
  	3.CPU会在适当的时候去处理底半部内容
  	4.底板可以休眠吗？？？？？？？？？？
  	5.实现方法：
  	  tasklet
  	  工作队列
  	  软中断
  	切记：底半部本质目的就是让所做的事情延后执行！  	      
     	      
  2.8.底半部机制之tasklet
  关键概念：
  中断上下文：中断的整个处理的过程(硬件处理,进入异常向量表,保护现场,处理中断,恢复现场)
  进程上下文：进程的整个处理的过程(进程创建,进程调度,进程抢占,进程休眠,进程的销毁)
  
  tasklet特点：
    1.基于软中断实现
    2.tasklet也有一个函数,此函数又称延后处理函数,函数中做
      要延后执行的事情(不紧急,耗时较长的内容)
    3.tasklet延后处理函数工作在中断上下文,所以不能进行休眠操作！
    4.切记本质：仅仅是延后执行的一种手段而已！并不是非要和顶半部一起
    使用，当然如果有中断,并且中断需要进行分顶半部和底半部,此时必须
    使用,没有中断,仅仅是延后执行,也可以使用tasklet
   
  tasklet数据结构：
  struct tasklet_struct {
  	void (*func)(unsigned long);
  	unsigned long data;
  	...
  };    
  func:tasklet延后处理函数,工作在中断上下文,不能进行休眠操作	      
       优先级高于进程,低于硬件中断;
       CPU会在“适当的时候”执行！
  data:给延后处理函数传递的参数,必须传递指针！
  
  配套函数：
  DECLARE_TASKLET(对象名,延后处理函数,传递参数);
  tasklet_schedule(&对象);//登记tasklet对象到内核,一旦注册
  			  内核会在适当的时候执行tasklet对象
  			  对应的延后处理函数;
  			  登记的目的是让内核知道还有一部分
  			  内容需要得到执行处理
  
  利用tasklet实现延后执行编程步骤：			  
  1.定义初始化tasklet对象
  2.编写tasklet对象对应的延后处理函数
    不能进行休眠操作
  3.随意在任何地方进行登记tasklet到内核即可  
    当然啦,如果有顶半部,一般在顶半部中断处理函数中进行登记
    再次强调：tasklet不一定非要和底半部配合使用！
    一旦登记完成,CPU在适当的时候执行对应的延后处理函数！
    
  案例：生硬的将按键驱动添加底半部机制
  	在底半部中实现打印按键的信息
  
  2.9.底半部机制之工作队列
  特点：
  1.工作队列本质也是延后执行的一种手段,不一定非要和顶半部一起使用
  2.工作队列对应的延后处理函数工作在进程上下文,所以可以进行
    休眠操作
  3.工作队列产生的本质就是解决tasklet的延后处理函数不能休眠的
    情形！ 
  4.切记：将来如果需要在延后处理的事情中有休眠操作,必须使用
    工作队列,如果没有休眠操作,并且要考虑到效率问题,选择tasklet,
    如果不考虑效率问题,随便选！
    
  工作队列数据结构：
  struct work_struct {
  	void (*func)(struct work_struct *work)
  	...
  };
  func:工作队列对应的延后处理函数,工作在进程上下文,可以进行
       休眠操作
       形参：work指针就是指向自己定义初始化的work对象
       利用大名鼎鼎的内核宏container_of进行传参
       建议写一个UC程序玩玩！     
  
  配套函数：
  
  //初始化工作对象,指定延后处理函数
  INIT_WORK(&对象名,延后处理函数);    
  schedule_work(&对象名); //登记工作队列的延后处理函数到
                          内核,一旦登记完毕,内核会在适当的
                          时候执行延后处理函数
  
  编程步骤：
  1.定义初始化工作队列对象
  2.编写延后处理函数
    可以进行休眠操作
  3.随意在任何地方进行登记即可,如果有顶半部,一般在顶半部进行
    登记


  2.10.底半部机制之软中断(了解)
  特点：
  1.同样是延后执行的一种手段
  2.软中断对应的延后处理函数工作在中断上下文,所以不能进行
  休眠操作；
  3.软中断对应的延后处理函数可以同一时刻运行在多个CPU上,
    所以软中断的效率最高,但是tasklet不行
    注意：软中断的延后处理函数必须具有可重入性
    例如：
    int g_data;
    void swap(int *a, int *b)
    {
    	g_data = *a;
    	*a = *b;
    	*b = g_data;
    	
    }//此函数不具备可重入性
    
    void swap1(int *a, int *b)
    {
    	int data;
    	data = *a;
    	*a = *b;
    	*b = data;
    }//此函数具备可重入性
  
   总结：函数的可重入性：
   1.尽量避免访问全局变量
   2.如果要访问全局变量,要注意互斥访问
     例如,访问全局变量的期间可以使用"锁"进行保护,最终导致
     代码的执行效率降低
  
 4.软中断的延后处理函数不能像tasklet,工作队列可以动态的加载
   或者卸载,只能静态编译到内核源码中(和zImage在一起编译)
 总结：由3,4可以看出虽然软中断的效率比较高,但是软件的设计
 比较复杂,软件的维护比较繁琐,所以由它的小弟tasklet来代替他

*************************************************************
3.linux内核时间相关和内核定时器
  3.1.硬件定时器(TIMER)
  特点：
  1.定时器硬件只要上电,就周期性,有规律得给CPU发送中断
    电信号(不像按键随机发送中断信号)
  2.发送中断电信号的频率可以通过软件进行配置
  3.linux内核已经实现好了定时器硬件的中断处理函数
    提示：cd /opt/kernel; vim arch/arm/mach-s5pv210/mach-cw210.c
    中代码片段：.timer	= &s5p_systimer
    定时器中断处理函数一般所做的工作：
    明确：定时器中断处理函数会按照一定的频率被内核调用！
    1.更新系统的运行时间
    2.更新墙上时间(实际时间)(wall-time)
    3.检查是否有超时的软件定时器,如果有超时的软件定时器
      调用定时器的超时处理函数
    4.检查进程的时间片是否用完,来决定是否进行进程的调度
    5.检查更新系统的资源,CPU利用率,内存的使用率等
   
   3.2.内核关于时间的相关概念
   HZ:内核常量,ARM架构HZ=100,X86架构HZ=1000
      例如：HZ=100,表明硬件定时器1秒钟给CPU发送100次定时器
            中断,每发送一次需要10ms
      例如：5*HZ：表示5秒钟
            HZ/2: 表示500ms
             
   jiffies:内核全局变量,数据类型unsigned long(32位)
   jiffies_64:内核全局变量,数据类型unsigned long long (64位)
   jiffies值取jiffies_64的低32位！
   
   jiffies_64用来记录自开机以来硬件定时器发生了多少次定时器中断
   每发生一次定时器中断,jiffies_64加1
   使用jiffies记录流失时间(时间间隔)
   切记注意：以后在代码中只要看到jiffies就是表示当前时间！
   unsigned long timeout = jiffies + 5*HZ;
   说明：
   jiffies:表示当前时间的时间
   5*HZ:5秒钟
   timeout: 5秒以后的时间
   
   注意：jiffies超时的判断问题(坑)
   unsigned long timeout = jiffies + 10*HZ;
   ...
   ...
   ... //会执行一段时间
   if (jiffies > timeout)
   	printk("超时\n");
   else
        printk("没超时\n"); 
   存在严重的漏洞！
   
   如果要判断是否超时,要利用内核提供的两个宏：
   time_after
   time_before
   这两个函数的具体使用利用souceinsight查看内核大神的判断写法即可
   
   作业：研究time_before和time_after如何解决jiffies漏洞问题
   
   参考代码：
   unsigned long timeout = jiffies + 2*HZ;
   unsigned long timeout = jiffies + HZ/2;
   unsigned long timeout = jiffies + 100;
    unsigned long timeout = jiffies + 1;
   
   3.3.linux内核软件定时器
   特点：
   1.内核软件定时器能够实现设置一个超时时间,超时时间到期以后
     内核会调用定时器的超时处理函数
   2.切记：内核软件定时器的超时处理函数基于软中断实现,所以不能进行
     休眠操作
     
   数据类型
   struct timer_list {
     	unsigned long expires;
     	void (*function)(unsigned long);
     	unsigned long data;
     	... 
   };
   expires:设置超时时间,例如：
           expires = jiffies + 5*HZ;
   function:超时处理函数,工作在中断上下文,不能进行休眠操作
            定时器到期,内核自动执行对应的超时处理函数
   data：给超时处理函数传递的参数,必须传递指针
   
   配套函数：
   //初始化定时器对象
   //注意：expires,function,data这个三个字段必须额外自己初始化
   init_timer(&定时器对象);
   //注册添加定时器对象到内核,一旦添加完毕,软件定时器开始
     倒计时(5,4,....0)
   add_timer(&定时器对象);
   //删除定时器对象从内核
   //定时器到期,内核会自动删除定时器对象
   //所以内核定时器的超时处理函数只执行一次
   del_timer(&定时器对象);
   //修改定时器
   mod_timer(&定时器对象,新超时时间);
       等价于：
       1.先删除定时器
       2.再修改定时器的超时时间
       3.最后将修改完以后的定时器添加注册到内核
   
  软件编程步骤：
  1.定义初始化定时器对象
  2.向内核注册定时器对象
  3.删除定时器对象
  4.定时器到期以后,如果有再次启动定时器的需求
    需要在定时器的超时处理函数中重新添加定时器
     
案例1：利用内核定时器,实现每隔2000ms打印一句话
案例2：利用内核定时器,实现每隔2000ms开关灯
案例3：案例内核定时器,实现驱动加载以后,灯的闪烁频率可以
       动态修改(2000ms,1000ms,500ms,100ms),提示不允许
       使用字符设备或者混杂设备编程框架,只需利用内核
       命令行传参的知识(module_param)  
提示：ms转jiffies(次数)
      msecs_to_jiffies(毫秒数)  
      
4.linux内核延时方法
  4.1.“延时”分两种：忙延时,休眠延时
  忙延时：当任务获取到CPU资源以后,如果进行忙延时,CPU原地空转
  	  忙延时可以用于中断和进程,应用在等待时间极短的场合
  休眠延时：休眠仅存于进程的世界里,休眠延时只能用于进程,
  	    进程休眠延时是指进程释放CPU资源给别的任务,用于等待时间
  	    较长的场合
  
  4.2.内核提供的忙延时的函数
  ndelay(纳秒数);//纳秒级延时
  ndelay(10); //忙延时10ns
  
  udelay(微秒数); //微秒级延时
  udelay(10); //忙延时10微秒
  
  mdelay(毫秒级); //毫秒级延时
  mdelay(5); //忙延时5毫秒
  注意：如果延时时间超过10ms,建议使用休眠延时
  
  4.3.内核提供的休眠延时的函数
  msleep(毫秒数);
  msleep(250); //休眠延时250ms
  
  ssleep(秒数); 
  ssleep(250); //休眠延时250s
  
  schedule(); //永久性休眠
  
  schedule_timeout(5*HZ); //休眠延时5秒
  
  大招：等待队列(随时随地休眠,随时随地唤醒)

	
	
	利用内核定时器,实现每隔2000ms开关灯
	内核定时器,实现驱动加载以后,灯的闪烁频率可以
        动态修改(2000ms,1000ms,500ms,100ms),提示不允许
        使用字符设备或者混杂设备编程框架,只需利用内核
        命令行传参的知识(module_param)   
  
  
  	    
  
  
     
   
                            
```